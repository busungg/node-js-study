# REPL 사용하기

자바스크립트는 스크립트 언어이므로 미리 컴파일을 하지 않아도 즉석에서 코드를 실행할 수 있습니다. 이전 장에서 브라우저 콘솔 탭에서 자바스크립트 코드를 입력보았을 것입니다.  
노드도 비슷한 콘솔을 제공하는데, 입력한 코드를 읽고(Read), 해석하고(Eval), 결과물을 반환하고(Print), 종료할 때까지 반복(Loop)한다고 해서 REPL(Read Eval Print Loop)이라고 부릅니다.
노드의 REPL을 직접 사용해보겠습니다. 윈도에서는 명령 프롬프트, 맥이나 리눅스에서는 터미널을 열고 node를 입력합니다. VS Code에서는 Ctrl + `를 누르면 터미널을 켤 수 있습니다. 앞으로는 명령 프롬프트나 터미널을 콘솔이라고 통칭하겠습니다.  
REPL을 종료하려면 Ctrl + C를 두 번 누르거나, REPL 창에 .exit를 입력하면 됩니다.

# JS 파일 실행하기

REPL에 직접 코드를 입력하는 대신 자바스크립트 파일을 만들어 실행해보겠습니다. 다음과 같은 자바스크립트 파일을 만들어봅시다. 파일은 아무 폴더(디렉터리) 안에 만들어도 됩니다. 하지만 예제 코드가 많으니 따로 폴더를 만들어 파일들을 모아두는 것이 편리할 것입니다.
콘솔에서 node [자바스크립트 파일 경로]로 실행합니다. 확장자(.js)는 생략해도 됩니다. REPL에서 입력하는 것이 아니므로 주의하세요. REPL이 아니라 콘솔에서 입력해야 합니다. 콘솔에서 REPL로 들어가는 명령어가 node고, 노드를 통해 파일을 실행하는 명령어는 node [자바스크립트 파일 경로]입니다.

```
    node helloWorld
```

# 모듈로 만들기

노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저의 자바스크립트와는 다릅니다. 모듈이란 특정한 기능을 하는 함수나 변수들의 집합입니다. 자체로도 하나의 프로그램이면서 다른 프로그램의 부품으로도 사용할 수 있습니다.
모듈로 만들어두면 여러 프로그램에 해당 모듈을 재사용할 수 있습니다. 자바스크립트에서 코드를 재사용하기 위해 함수로 만드는 것과 비슷합니다.  
**_require 함수 안에 불러올 모듈의 경로를 적어줍니다. 앞의 예제에서는 같은 폴더 안에 파일을 만들었지만, 다른 폴더에 있는 파일도 모듈로 사용할 수 있습니다. require 함수의 인자로 제공하는 경로만 잘 지정해주면 됩니다. 파일 경로에서 js나 json 같은 확장자는 생략할 수 있습니다._**

# 노드 내장 객체 알아보기

### 1. global

브라우저의 window와 같은 전역 개체입니다. 전역 객체이므로 모든 파일에서 접근할 수 있습니다. 또한, window.open 메서드를 그냥 open으로 호출할 수 있는 것처럼 global도 생략할 수 있습니다.
이전 절에서 사용했던 require 함수에서도 global.require에서 global이 생략된 것입니다.
노드 콘솔에 로그를 기록하는 console 객체도 원래는 global.console입니다.  
global 객체 내부에는 매우 많은 속성이 들어 있습니다. 이 절에서 배울 내용들이 global 객체 안에 있습니다.  
전역 객체라는 점을 이요하여 간단한 데이터를 파일끼리 공유할 때 사용하기도 합니다. globalA.js와 globalB.js를 같은 폴더에 생성해봅시다.  
globalA 모듈의 함수는 global.message 값을 반환합니다. globalB.js에서는 global 객체에 속성명이 message인 값을 대입하고 globalA 모듈의 함수를 호출합니다. 콘솔 결과를 보면 globalB에서 넣은 global.message 값을 globalA에서도 접근할 수 있음을 알 수 있습니다.

### 2. console

console 객체는 보통 디버깅을 위해 사용됩니다. 개발 중 변수에 값이 제대로 들어 있나 확인하기 위해 사용하기도 하고, 에러 발생 시 에러 내용을 콘솔에 표시하기 위해서도 사용하며, 코드 실행 시간을 알아보려고 할 때도 사용합니다.

1. console.time(레이블)
   - console.timeEnd(레이블) 과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정합니다.
   - ```
        console.time('시간 측정');
        for(let i = 0; i < 100000; i++) {
            continue;
        }
        console.timeEnd('시간 측정');
     ```
2. console.log(내용)
   - 평범한 로그를 콘솔에 표시합니다. console.log(내용, 내용, ...)처럼 여러 내용을 동시에 표시할 수도 있습니다.
3. console.error(에러 내용)
   - 에러를 콘솔에 표시합니다.
4. console.dir(객체, 옵션)
   - 객체를 콘솔에 표시할 때 사용합니다. 첫 번째 인자로 표시할 객체를 넣고, 두 번째 인자로 옵션을 넣습니다. 옵션의 colors를 true로 하면 콘솔에 색이 추가되어 보기가 한결 편해집니다. depth는 객체 안의 객체를 몇 단계까지 보여줄지를 결정합니다. 기본값은 2 입니다.
   - ```
        console.dir(obj, { colors: false, depth: 2});
        console.dir(obj, { colors: true, depth: 1});
     ```
5. console.trace(레이블)
   - 에러가 어디서 발생했는지 추적할 수 있게 해줍니다. 보통은 에러 발생 시 에러 위치를 알려주므로 자주 사용하지는 않지만, 위치가 나오지 않는다면 사용할만 합니다.

### 3. 타이머

setTimeout, setInterval, setImmediate는 노드에서 window대신 global 객체 안에 들어 있습니다.

1. setTimeout(콜백 함수, 밀리초)
   - 주어진 밀리초(1000분의 1초) 이후에 콜백 함수를 실행합니다.
2. setInterval(골백 함수, 밀리초)
   - 주어진 밀리초마다 콜백 함수를 반복 실행합니다.
3. setImmediate(콜백 함수)
   - 콜백 함수를 즉시 실행합니다.

이 타이머 함수들은 모두 아이디를 반환합니다. 아이디를 사용하여 타이머를 취소할 수 있습니다.

1. clearTimeout(아이디)
   - setTimeout을 취소합니다.
2. clearInterval(아이디)
   - setInterval을 취소합니다.
3. clearImmediate(아이디)
   - setImmediate를 취소합니다.

### 4. \_\_filename, \_\_dirname

노드에서는 파일 사이에 모듈 관계가 있는 경우가 많아 현재 파일의 경로나 파일명을 알아야 하는 경우가 있습니다. 노드는 \_\_filename, \_\_dirname이라는 키워드로 경로에 대한 정보를 제공합니다.  
파일에 \_\_filename과 \_\_dirname을 넣어두면 실행 시 현재 파일명과 파일 경로로 바뀝니다.

### 5. module, exports

지금까지는 모듈을 만들 때 module.exports만 사용했는데, module 객체 말고 exports 객체로도 모듈을 만들 수 있습니다.

```
exports.odd = '홀수입니다.'
exports.even = '짤수입니다.'
```

module.exports로 한 번에 대입하는 대신, 각각의 변수를 exports 객체에 하나씩 넣었습니다. **_동일하게 동작하는 이유는 module.exports와 exports가 같은 객체를 참조하기 때문입니다._**  
실제로 console.log(module.exports === exports)를 하면 true가 나옵니다. 따라서 exports 객체에 add함수를 넣으면 module.exports에도 add 함수가 들어갑니다.

### 6. process

process 객체는 현재 실행되고 있는 노드 프로세스에 대한 정보를 담고 있습니다. provess 객체 안에는 다양한 속성이 있습니다.

1. process.version
   - 설치된 노드의 버전입니다.
2. process.arch
   - 프로세서 아키텍처 정보입니다. arm, ia32 등의 값일 수도 있습니다.
3. process.platform
   - 운영체제 플랫폼 정보입니다. linux나 darwin, freebsd, win32등의 값일 수도 있습니다.
4. process.pid
   - 현재 프로세스의 아이디입니다. 프로세스를 여러 개 가질 때 구분할 수 있습니다.
5. process.uptime()
   - 프로세스가 시작된 후 흐른 시간입니다. 단위는 초입니다.
6. process.execPath
   - 노드의 경로입니다.
7. process.cwd()
   - 현재 프로세스가 실행되는 위치입니다.
8. process.cpuUsage()
   - 현재 cpu 사용량입니다.

#### 6.1 process.env

REPL에 process.env를 입력하면 매우 많은 정보가 출력됩니다. 자세히 보면 이 정보들이 시스템의 환경 변수임을 알 수 있습니다.  
process.env는 서비스의 중요한 키를 저장하는 공간으로도 사용됩니다. 서버나 데이터베이스의 비밀번호와 각종 API키를 코드에 직접 입력하는 것은 위험합니다. 혹여 서비스가 해킹당해 코드가 유출되었을 때 비밀번호가 코드에 남아 있어 추가 피해가 발생할 수 있습니다.  
따라서 중요한 비밀번호는 다음과 같이 process.env의 속성으로 대체합니다.

```
const secretId = process.env.SECRET_ID;
const secretCode = process.env.SECRET_CODE;
```

이제 process.env에 직접 SECRET_ID와 SECRET_CODE를 넣어주면 됩니다. 넣는 방법은 운영체제마다 차이가 있습니다. 하지만 한번에 모든 운영체제에 동일하게 넣을 수 있는 방법이 있습니다. dotenv를 사용할 때 배웁니다.

#### 6.2 process.nextTick(콜백)

이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선으로 처리하도록 만듭니다.
process.nextTick은 setImmediate나 setTimeout보다 먼저 실행됩니다. 또한 resolve된 Promise도 nextTick처럼 다른 콜백들보다 우선시 됩니다. 그래서 **_process.nextTick과 Promise를 마이크로태스크(microtask)라고 따로 구분지어 부릅니다._**

#### 6.3 process.exit(코드)

실행 중인 노드 프로세스를 종료합니다. 서버에 이 함수를 사용하면 서버가 멈추므로 서버에는 거의 사용하지 않습니다. 하지만 서버 외의 독립적인 프로그램에서는 수동으로 노드를 멈추게 하기 위해 사용합니다.
setInterval로 반복되고 있는 코드를 process.exit()로 멈출 수 있습니다.

```
   let i = 1;
   setInterval(() => {
      if(i === 5) {
         console.log('종료');
         process.exit();
      }
      console.log(i);
      i += 1;
   });
```

process.exit 메서드는 인자로 코드 번호를 줄 수 있습니다. 인자를 주지 않거나 0이면 정상 종료를 뜻하고, 1을 주면 비정상 종료를 뜻합니다. 만약 에러가 발생해서 종료하는 경우에는 1을 넣어주면 됩니다.

# 노드 내장 모듈 사용하기

노드는 웹 브라우저에서 사용되는 자바스크립트보다 더 많은 기능을 제공합니다. 운영체제 정보에도 접근할 수 있고, 클라이언트가 요청한 주소에 대한 정보도 가져올 수 있습니다. 바로 노드에서 제공하는 모듈을 사용하면 됩니다.

### 1. os

os 모듈은 운영체제의 정보를 가져올 수 있습니다.

1. os.arch()
   - process.arch와 동일합니다.
2. os.platform()
   - process.platform과 동일합니다.
3. os.type()
   - 운영체제의 종류를 보여줍니다.
4. os.uptime()
   - 운영체제 부팅 이후 흐른 시간(초)를 보여줍니다. process.uptime()은 노드의 실행 시간이었습니다.
5. os.hostname()
   - 컴퓨터의 이름을 보여줍니다.
6. os.release()
   - 운영체제의 버전을 보여줍니다.
7. os.homedir()
   - 홈 디렉터리 경로를 보여줍니다.
8. os.tmpdir()
   - 임시 파일 저장 경로를 보여줍니다.
9. os.cpus()
   - 컴퓨터의 코어 정보를 보여줍니다.
10. os.freemem()

    - 사용 가능한 메모리(RAM)를 보여줍니다.

11. os.totalmem()

    - 전체 메모리 용량을 보여줍니다.

12. os.constants 객체
    - 각종 에러와 신호에 대한 정보가 담겨 있습니다. 에러가 발생했을 때, EADDRINUSE나 ECONNRESET 같은 에러 코드를 함께 보여줍니다.

os 모듈은 주로 컴퓨터 내부 자원에 빈번하게 접근하는 경우 사용됩니다. 즉, 일반적인 웹 서비스를 제작할 때는 사용 빈도가 높지 않습니다. 하지만 운영체제별로 다른 서비스를 제공하고 싶을 때 os 모듈이 유용할 것입니다.

### 2. path

폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈입니다. path 모듈이 필요한 이유 중 하나는 운영체제별로 경로 구분자가 다르기 때문입니다. 크게 Windows 타입과 POSIX타입으로 구분됩니다. POSIX는 유닉스 기반의 운영체제들로 macOS와 리눅스가 속해 있습니다.

1. Windows
   - C:\Users\AAA 처럼 \로 구분합니다.
2. POSIX
   - /home/AAA 처럼 /로 구분합니다.

이외에도 파일 경로에서 파일명이나 확장자만 따로 떼어주는 기능도 구현해두어 직접 구현할 필요 없이 편리하게 사용할 수 있습니다.

1. path.sep
   - 경로의 구분자입니다. Windows는 \, POSIX는 /입니다.
2. path.delimiter
   - 환경 변수의 구분자입니다. process.env.PATH를 입력하면 여러 개의 경로가 이 구분자로 구분되어 있습니다. Windows는 세미콜론(;) 이고 POSIX는 콜론(:) 입니다.
3. path.dirname(경로)
   - 파일이 위치한 폴더 경로를 보여줍니다.
4. path.extname(경로)
   - 파일의 확장자를 보여빈디ㅏ.
5. path.basename(경로,확장자)
   - 파일의 이름(확장자 포함)을 보여줍니다., 파일의 이름만 표시하고 싶다면 basename의 두 번째 인자로 파일의 확장자를 넣어주면 됩니다.
6. path.parse(경로)
   - 파일 경로를 root, dir, base, ext, name으로 분리합니다.
7. path.format(객체)
   - path.parse()한 객체를 파일 경로로 합칩니다.
8. path.normalize(경로)
   - /나 \를 실수로 여러 번 사용했거나 혼용했을 때 정상적인 경로로 변환해줍니다.
9. path.isAbsolute(경로)
   - 파일의 경로가 절대경로인지 상대경로인지 true나 false로 알려줍니다.
10. path.relative(기준경로, 비교경로)
    - 경로를 두 개 넣으면 첫 번째 경로에서 두 번째 경로로 가는 방법을 알려줍니다.
11. path.join(경로, ...)
    - 여러 인자를 넣으면 하나의 경로로 합쳐줍니다. 상대경로인 ..(부모 디렉터리)과 .(현 위치)도 알아서 처리해줍니다.
12. path.resolve(경로, ...)
    - path.join()과 비슷하지만 차이가 있습니다.
    - path.resolve는 /를 만나면 절대경로를 인식해서 앞의 경로를 무시하고, path.join인 상대경로로 처리합니다.
      - ```
         path.join('/a', '/b', 'c') // 결과 /a/b/c/
         path.resolve('/a', '/b', 'c') // 결과 /b/c
        ```

### 3. url

인터넷 주소를 쉽게 조작하도록 도와주는 모듈입니다. url 처리에는 크게 두 가지 방식이 있습니다. 노드 버전 7에서 추가된 WHATWG(웹 표준을 정하는 단체의 이름) 방식의 url과 예전부터 노드에서 사용하던 방식의 url이 있습니다. 또한 기존 노드 방식에서는 두 메서드를 주로 사용합니다.

1. url.parse(주소)
   - 주소를 분해합니다. WHATWG방식과 비교하면 username과 password 대신 auth속성이 있고, searchParams 대신 query가 있습니다.
2. url.format(객체)
   - WHATWG 방식의 url과 기존 노드의 url 모두 사용할 수 있습니다. 분해되었던 url 객체를 다시 원래 상태로 조립합니다.

WHATWG와 노드의 url은 취향에 따라 사용하면 되지만 노드의 url 형식을 꼭 사용해야 하는 경우가 있습니다. **_주소가 host 부분 없이 pathname 부분만 오는 경우(/book/bookList.aspx), WHATWG 방식은 이 주소를 처리할 수 없습니다._**  
또한 WHATWG 방식은 search 부분을 searchParams라는 특수한 객체로 반환하므로 우용합니다.
search 부분은 보통 주소를 통해 데이터를 전달할 때 사용됩니다. search는 물음표(?)로 시작하고, 그 뒤에 키=값 형식으로 데이터를 전달합니다. 여러 키가 있을 경우에는 &로 구분합니다.

1. getAll(키)
   - 키에 해당하는 모든 값들을 가져옵니다. category 키에는 두 가지 값, 즉 nodejs와 javascript의 값이 들어 있습니다.
2. get(키)
   - 키에 해당하는 첫 번째 값만 가져옵니다.
3. has(키)
   - 해당 키가 있는지 없지는지를 검사합니다.
4. keys()
   - searchParams의 모든 키를 반복기(iterator, ES2015 문법) 객체로 가져옵니다.
5. values()
   - searchParams의 모든 값을 반복기 객체로 가져옵니다.
6. append(키, 값)
   - 해당 키를 추가합니다. 같은 키의 값이 있다면 유지하고 하나 더 추가합니다.
7. set(키, 값)
   - append와 비슷하지만 같은 키의 값들을 모두 지우고 새로 추가합니다.
8. delete(키)
   - 해당 키를 제거합니다.
9. toString()
   - 조작한 searchParams 객체를 다시 문자열로 만듭니다. 이 문자열을 search에 대입하면 주소 객체에 반영됩니다.

**_query 같은 문자열보다 searchParams가 유용한 이유는 query의 경우 다음 절에 나오는 querystring 모듈을 한 번 더 사용해야 하기 때문입니다._**

### 4. querystring
WHATWG 방식의 url 대신 기존 노드의 url을 사용할 때 search 부분을 쉽게 객체로 만드는 모듈입니다.

1. querystring.parse(쿼리)
   - url의 query 부분을 자바스크립트 객체로 분해해줍니다.
2. querystring.stringify(객체)
   - 분해된 query 객체를 문자열로 다시 조립해줍니다.

### 4. crypto
다양한 방식의 암호화를 도와주는 모듈입니다.  
고객의 비밀번호는 반드시 암호화해야 합니다. 비밀번호를 암호화하지 않으면 비밀번호를 저장해둔 데이터베이스가 해킹당하는 순간 고객들의 비밀번호도 고스란히 해커 손에 넘어가고 맙니다.

#### 4.1 단방향 암호화
비밀번호는 보통 단방향 암호화 알고리즘을 사용해서 암호화합니다. 단방향 암호화란 복호화할 수 없는 암호화 방식을 뜻합니다. 복호화는 암호화된 문자열을 원래 문자열로 되돌려놓는 것을 의미합니다. 즉, 단방향 암호화는 한 번 암호화하면 원래 문자열을 찾을 수 없습니다.
***보통 고객의 비밀번호를 암호화헤서 데이터베이스에 저장합니다. 그리고 로그인할 때마다 입력받은 비밀번호를 같은 암호화 알고리즘으로 암호화한 후, 데이터베이스의 비밀번호와 비교하게됩니다.***   
단방향 암호화 알고리즘은 주로 해시 기법을 사용합니다. 해시 기법이란 어떠한 문자열을 고정된 길이의 다른 문자열로 바꿔버리는 방식입니다.

1. createHash(알고리즘)
   - 사용할 해시 알고리즘을 넣어줍니다. md5, sha1, sha256, sha512등이 가능하지만, md5와 sha1은 이미 취약점이 발견되었습니다. 현재는 sha512 정도로 충분하지만, 나중에 sha512마저도 취약해지면 더 강화된 알고리즘으로 바꿔야 합니다.
2. update(문자열)
   - 변환할 문자열을 넣어줍니다.
3. digest(인코딩)
   - 인코딩할 알고리즘을 넣어줍니다. base64, hex, latin1이 주로 사용되는데, 그 중 base64가 결과 문자열이 가장 짧아 애용됩니다. 결과물로 변환된 문자열을 반환합니다.

해킹용 컴퓨터의 성능이 발달함에 따라 기존 해시 알고리즘들이 위협받고 있는데 그래서 현재는 주로 pobkdf2나 bcrypt, scrypt라는 알고리즘으로 비밀번호를 암호화하고 있습니다. 이중에 노드에서 지원하는 pbkdf2가 있습니다. pbkdf2는 간단히 말하면 기존 문자열에 salt라고 불리는 문자열을 붙인 후 해시 알고리즘을 반복해서 적용하는 것입니다.    
pbkdf2는 간단하지만 bcrypt나 scrypt보다 취약하므로 나중에 더 나은 보안이 필요하면 scrypt방식을 사용하면 됩니다.

#### 4.2 양방향 암호회
양방향 대칭형 암호화는 암호화된 문자열을 복호화할 수 있습니다. 여기에서는 키(열쇠)라는 것이 사용됩니다. 암호를 복호화하려면 암호화할 때 사용한 키와 같은 키를 사용해야 합니다.

1. crypto.createCipher(알고리즘, 키)
   - 암호화 알고리즘과 키를 넣어줍니다. 암호화 알고리즘은 aes-256-cbc를 사용했습니다. 다른 알고리즘을 사용해도 됩니다. 사용 가능한 알고리즘 목록은 crypto.getCiphers()를 사용하면 볼 수 있습니다.
2. cipher.update(문자열, 인코딩, 출력 인코딩)
   - 암호화할 대상과 대상의 인코딩, 출력 결과물의 인코딩을 넣어줍니다. 보통 문자열은 utf8 인코딩을, 암호는 base64를 많이 사용합니다.
3. cipher.final(출력 인코딩)
   - 출력 결과물의 인코딩을 넣어주면 암호화가 완료됩니다.
4. crypto.createDecipher(알고리즘, 키)
   - 복호화할 때 사용합니다. 암호화할 때 사용했던 알고리즘과 키를 그대로 넣어주어야 합니다.
5. decipher.update(문자열, 인코딩, 출력 인코딩)
   - 암호화된 문장, 그 문장의 인코딩, 복호화할 인코딩을 넣어줍니다. createCipher의 update()에서 utf8, base64 순으로 넣었다면 createDecipher의 update()에서는 base64, utf8순으로 넣으면 됩니다.
6. decipher.final(출력 인코딩)
   - 복호화 결과물의 인코딩을 넣어줍니다.

### 5. util
util이라는 이름처럼 각종 편의 기능을 모아둔 모듈입니다.  
util 모듈에서 자주 사용되는 두 메서드입니다.

1. util.deprecate
   - 함수가 deprecated 처리되었음을 알려줍니다. 첫 번째 인자로 넣은 함수를 사용했을 때 경고 메세지가 출력됩니다. 두 번째 인자로 경고 메시지 내용을 넣으면 됩니다. 함수가 조만간 사라지거나 변경될 때 알려줄 수 있어 유용합니다.
2. util.promisify
   - 콜백 패턴을 프로미스 패턴으로 바꿔줍니다. 바꿀 함수를 인자로 제공하면 됩니다. 이렇게 바꾸어두면 async/await 패턴까지 사용할 수 있어 좋습니다.

# 파일 시스템 접근하기
fs 모듈은 파일 시스템에 접근하는 모듈입니다. 즉 파일을 생성하거나 삭제하고, 읽거나 쓸 수 있습니다. 폴더도 만들었다 지웠다 할 수 있습니다.    
readFile의 결과물은 버퍼라는 형식으로 제공됩니다. 버퍼는 사람이 읽을 수 있는 형식이 아니므로 toString()을 사용해 문자열로 변환하였습니다.
writeFile 메서드를 사용하면 파일을 생성할 수 있는데 writeFile 메서드에 생성될 파일의 경로와 내용을 입력해줍니다.

### 1. 동기 메서드와 비동기 메서드
readFile-async.js 파일은 반복 실행할 때마다 결과가 달라집니다.    
비동기 메서드들은 백그라운드에 해당 파일을 읽으라고만 요청하고 다음 작업으로 넘어갑니다. 따라서 파일 읽기 요청만 세 번을 보내고 console.log('끝')을 찍습니다. 나중에 읽기가 완료되면 백그라운드가 다시 메인 스레드에 알림을 줍니다. 메인 스레드는 그제서야 등록된 콜백 함수를 실행합니다.    
readFile-sync.js 파일은 readFileSync() 라는 메서드를 사용하는데 기존과 달리 콜백 함수를 넣는 대신 직접 return 값을 받아오고 그 값을 다음 줄부터 바로 사용할 수 있습니다.   
사용은 쉬우나 요청이 수백 개 이상 들어왔을 때 성능에 문제가 생깁니다. Sync 메서드를 사용할 땨ㅐ는 이전 작업이 완료되어야 다음 작업을 진행할 수 있습니다. ***즉, 백그라운드가 작업하는 동안 메인 스레드는 아무것도 못하고 대기하고 있어야 하는 것입니다. 메인 스레ㅐ드가 일을 하지 않고 노는 시간이 생기기 때문에 비효율적입니다.***

### 2. 버퍼와 스트림 이해하기
파일을 읽거나 쓰는 방식에는 크게 두 가지 방식 ***즉 버퍼를 이용하는 방식과 스트립을 이용하는 방식이 있습니다.***

1. 버퍼링
   - 노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해두며, 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 해줍니다.
   - 메모리에 저장된 데이터가 바로 버퍼입니다.
   - 버퍼를 직접 다룰 수 있는 클래스가 있는데 바로 Buffer 입니다.
      - buffer.js
   - from(문자열)
      - 문자열을 버퍼로 바꿀 수 있습니다. length 속성은 버퍼의 크기를 알려줍니다.
   - toString(버퍼)
      - 버퍼를 다시 문자열로 바꿀 수 있습니다. 이때 base나 hex를 인자로 넣으면 해당 인코딩으로 변환할 수 있습니다.
   - concat(배열)
      - 배열 안에 든 버퍼들을 하나로 합칩니다.
   - alloc(바이트)
      - 빈 버퍼를 생성합니다. 바이트를 인자로 지정해주면 해당 크기의 버퍼가 생성됩니다.

2. 스트리밍
   - 용량이 100MB인 파일이 있으면 읽을 때 메모리에 100MB의 버퍼를 만들어야 합니다. 이 작업을 동시에 열 개만 해도 1GB에 달하는 메모리가 사용됩니다. 특히 서버 같이 몇 명이 이용할지 모르는 환경에서는 메모리 문제가 발생할수 있습니다.  
   또한, 모든 내용을 버퍼에 다 쓴 후에야 다음 동작으로 넘어가므로 파일 읽기, 압축, 파일 쓰기 등의 조작을 연달아 할 때 매번 전체 용량을 버퍼로 처리해야 다음 단계로 넘어갈 수 있습니다.
   - 그래서 버퍼의 크기를 작게 만들어서 여러 번에 나눠서 보내는 방식이 등장했습니다. 예를 들면 버퍼 1MB를 만든 후 100MB 파일을 백 번에 걸쳐 보내는 것입니다.
   - 이를 편리하게 만든 것이 스트림입니다.